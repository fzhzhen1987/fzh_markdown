# 彻底搞懂Cache

- [0.背景知识](#1)  
- [1.Cache工作原理](#2)  
- [2.Cache与主存的映射关系](#3)  
- [3.Cache中主存块的替换算法](#4)  
- [4.Cache写策略](#5)  

<h4 id="1">[0.背景知识]</h>  

- 局部性原理  
	1. 时间局部性:  
		> - 在最近的**未来要用到**的信息,很可能是现在正在使用的信息.  
		> - 因为程序中存在循环  

	1. 空间局部性  
		> - 在最新未来要用到的信息,很可能与现在正在使用的信息在存储空间上相邻.  
		> - 因为指令通常是顺序存放,顺序执行.  
		> - 数据一般也是以向量数组形式簇聚地存储在一起.  

		- 空间局部性的评判标准  
			> - 访问顺序与存放顺序一致⇒空间局部顺序好  
			>	空间局部好的例子:A,B两个数据**相邻存储**,并且程序为**访问A后访问B**  

			> <details>
			> <summary>例子1截图:**按行存储**的存储顺序为: a[0][0] → a[0][1] → a[0][n]</summary>
			> <img src= example_1.png />
			> </details>
			>
			> - 程序A的**访问顺序**:空间局部性**好**  
			> a[0][0] → a[0][1]  
			> - 程序B的**访问顺序**:空间局部性**差**  
			> a[0][0] → a[1][0]  
			> - 程序AB的**时间局部性**都差:  
			> 每个数据元素**只被访问一次**  

<h4 id="2">[1.Cache工作原理]</h>  

<details>
<summary>工作原理示意图</summary>
<img src= Cache_1.png />
</details>

- 存储器:  
	> - RAM: 随机存储器  
	> - ROM: 只读存储器  

	- RAM:
		> - SRAM(Cache): **静态**随机存储器  
		>> - 特点:信息读出后,仍保持原状态不需再生(**非破坏性读出**)  
		> - DRAM(主存): **动态**随机存储器  

- 命中率:CPU欲访问信息已在Cache中的比率  
	> H(命中率) = Nc/(Nc + Nm)  
	>> NC: 命中次数. Nm: 访问主存的次数.  
	>
	> Ta(平均访问时间) =H*Tc + (1 - H)*Tm  
	>> Tc: 命中Cache的访问时间. Tm: 未命中Cache,访问主存的时间.  

<h4 id="3">[2.Cache与主存的映射关系]</h>  

> 概念:Cache保存了主存的**部分数据**,导致Cache的容量小于主存容量.  
> 更进一步导致:Cache的**地址位数小于**主存的地址位数.  

> <details>
> <summary>为了可以实现映射: 需要主存块和缓存块(**也就是缓存的一行**)大小相同,并且**块内字节数相同** </summary>
> <img src= Cache_2.png />
> </details>  
>
> 主存字块0中有**4个字节**,所以Cache中复制来的字块0也要有4个字节.  

> <details>
> <summary>主存地址结构图(**需要分页存储管理知识**)</summary>
> <img src= Cache_3.png />
> </details>
>
> - 主存地址分为2块:
>	- 主存块号m
>	- 块内地址

> <details>
> <summary>Cache地址结构图</summary>
> <img src= Cache_4.png />
> </details>  
>
> - Cache地址分为2块:  
>	- 块号c  
>	- 块内地址  

> - 主存块m值要远大于Cache的块号c值  
> - 当要查找某个数据:  
>	1. 定位数据在哪个块中  
>	1. 再定位数据再块内第几个字节  
> - 分页管理,指令在哪个页面,再使用页内偏移量来确定在页面内的第几条指令.  

- Cache映射关系: 把主存中的数据按某个规则装入Cache  
	1. 直接映射:  
		> 主存中的每一块只能装入Cache块的**唯一位置**,  
		> 若冲突,**则原来的块被无条件替换.**  
		> - 若Cache共有 **2^c^** ,那么主存块号的**低c位**为对应的Cache行号.  
		>> 举例: 假设映射关系 Cache行号 = 主存块号 % Cache总行数  
		>> 主存块号13,Cache总行数为**2^2^**  
		>> 则 Cache行号 = 13%4 = 1, 11**01**,  
		>> 末尾的01是Cache的行号,也是主存块的低c位,也就是cache的行数以2进制表示的长度.  
		
		> 设Cache有2的c次方行,主存有2的m次方块.  
		> **CPU访存时,生成一个访存地址.**  
		> <details>
		> <summary>Cache和主存的映射关系</summary>
		> <img src= Cache_5.png />
		> </details>
		>
		> Cache标记位(m-c)位等于主存地址的前(m-c)位.  
		
		> <details>
		> <summary>本题Cache为字节编址</summary>
		> <img src= Cache_6.png />
		> </details>
		>
		> 依据:Cahe容量16KB( **2^14^** B),  
		> 以字节编址,相当于2的14次方个B除以B = Cache地址为14位  

	1. 全相联映射  
		> 允许主存中每一个字块映射到cache块中的任何位置  
		>
		> <details>
		> <summary>主存块号m位就可以等于cache标记m位</summary>
		> <img src= 全相联映射.png />
		> </details>

	1. 组相联映射  
		> 将cache分成Q个大小相等的组,每个主存块可装入固定组,每个主存块可以装入固定组的任意行.  
		> <details>
		> <summary>组间采用直接映射,组内采用全相联映射</summary>
		> <img src= 组相联映射.png />
		> </details>
		>
		> cache组号 = 主存块号%cache组数  
		>> 若cache有 **2^q^** 组  
		>> 那么主存块号的低q位即为对应的cache组号.  
		>
		>> <details>
		>> <summary>组相联例题</summary>
		>> <img src= 组相联例题.png />
		>> </details>
		>>
		>> 因为主存块大小为32字节,所以块内地址为5位  
		>> Cache 64行,并且是4路,所以64/4=16 所以组号需要用4位表示.  
		>> 2593 %b = 0001 0100 0100 0010 0000  
		>> 所以组号为p[8:5] = 0001  

	1. 三种映射方法总结  
		> - 主存分块  
		>	 <details>
		>	 <summary>主存物理地址 = 主存块号 + 块内地址</summary>
		>	 <img src= 主存分块.png />
		>	 </details>
		>
		>	当锁定块内地址中个某个小块,会将所在的整个大块加载到cache中.  
		>
		> <details>
		> <summary>3种映射对比图</summary>
		> <img src= 3种映射对比.png />
		> </details>
		>
		>> - 全相联映射: 全随便相联(标记长度为主存块号的2进制位数)  
		>> - 组相联映射: 组间被确定,组内随便放.(标记长度在全相联和直接映射之间)  
		>>	比如4路组相联,由cache总行号/4路= 有几组,将组变成2进制得到组地址  
		>> - 直接映射: 特殊的组相联映射,为1路组相联映射,则组数= caache行号(标记长度最短)  
		>> - 特别注意: 标记是唯一要保存在Cache中的数据,标记位越短越好  
		> <details>
		> <summary>组相联综合题</summary>
		> <img src= 组相联综合题.png />
		> </details>
		>
		>> 由每块16B 得出 块内地址位宽4bit  
		>> 由128KB的cache和每块16B 得出 cache line总数=128KB/16B = **2^(17-4)^**  
		>> 由8路组相联 得出 组号 = **2^(13-3)^**,组号位宽 = 10 位  
		>> 因为1234567H是**2^28^**,所以前 **2^28-10-4^** 位 是tag  

